<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>hhx.github.io by hhxcode</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">hhx.github.io</h1>
      <h2 class="project-tagline">hhx Pages</h2>
      <a href="https://github.com/hhxcode/hhx.github.io" class="btn">View on GitHub</a>
      <a href="https://github.com/hhxcode/hhx.github.io/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/hhxcode/hhx.github.io/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="okhttp" class="anchor" href="#okhttp" aria-hidden="true"><span class="octicon octicon-link"></span></a>OKHTTP</h3>

<p>Android系统提供了两种HTTP通信类，HttpURLConnection和HttpClient。
尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。
OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。</p>

<p>OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>

<p>使用 OkHttp 无需重写您程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。</p>

<h3>
<a id="基本使用" class="anchor" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本使用</h3>

<p>HTTP GET
    OkHttpClient client = new OkHttpClient();</p>

<pre><code>String run(String url) throws IOException {
    Request request = new Request.Builder().url(url).build();

    Response response = client.newCall(request).execute();
    return response.body().string();
}

public static void main(String[] args) throws IOException {
    GetExample example = new GetExample();
    String response = example.run("https://raw.github.com/square/okhttp/master/README.md");
    System.out.println(response);
}
</code></pre>

<p>Request是OkHttp中访问的请求，Builder是辅助类。Response即OkHttp中的响应。</p>

<p>Response类：
  /**</p>

<ul>
<li>Returns true if the code is in [200..300), which means the request was</li>
<li>
<p>successfully received, understood, and accepted.
*/
public boolean isSuccessful() {
  return code &gt;= 200 &amp;&amp; code &lt; 300;
}
HTTP POST
POST提交String数据
public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");</p>

<p>private final OkHttpClient client = new OkHttpClient();</p>

<p>public void run() throws Exception {
    String postBody = "" + "Releases\n" + "--------\n" + "\n" + " * <em>1.0</em> May 6, 2013\n" + " * <em>1.1</em> June 15, 2013\n"
            + " * <em>1.2</em> August 11, 2013\n";</p>

<pre><code>Request request = new Request.Builder().url("https://api.github.com/markdown/raw")
        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)).build();

Response response = client.newCall(request).execute();
if (!response.isSuccessful())
    throw new IOException("Unexpected code " + response);

System.out.println(response.body().string());
</code></pre>

<p>}</p>

<p>public static void main(String... args) throws Exception {
    new PostString().run();
}
使用Request的post方法来提交请求体RequestBody</p>
</li>
</ul>

<p>POST提交键值对
OkHttpClient client = new OkHttpClient();
String post(String url, String json) throws IOException {</p>

<pre><code> RequestBody formBody = new FormEncodingBuilder()
.add("platform", "android")
.add("name", "bug")
.add("subject", "XXXXXXXXXXXXXXX")
.build();

  Request request = new Request.Builder()
  .url(url)
  .post(body)
  .build();

  Response response = client.newCall(request).execute();
if (response.isSuccessful()) {
    return response.body().string();
} else {
    throw new IOException("Unexpected code " + response);
}
</code></pre>

<p>}</p>

<p>POST提交File
public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");</p>

<pre><code>private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception {
    File file = new File("README.md");

    Request request = new Request.Builder().url("https://api.github.com/markdown/raw")
            .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file)).build();

    Response response = client.newCall(request).execute();
    if (!response.isSuccessful())
        throw new IOException("Unexpected code " + response);

    System.out.println(response.body().string());
}

public static void main(String... args) throws Exception {
    new PostFile().run();
}
</code></pre>

<h3>
<a id="总结" class="anchor" href="#%E6%80%BB%E7%BB%93" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h3>

<p>通过上面的例子我们可以发现，OkHttp在很多时候使用都是很方便的，而且很多代码也有重复，因此特地整理了下面的工具类。
注意：</p>

<p>OkHttp官方文档并不建议我们创建多个OkHttpClient，因此全局使用一个。 如果有需要，可以使用clone方法，再进行自定义。这点在后面的高级教程里会提到。</p>

<p>enqueue为OkHttp提供的异步方法，入门教程中并没有提到，后面的高级教程里会有解释。
private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
    private static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");</p>

<pre><code>private volatile static AsyncOkHttp instance;

private final OkHttpClient mHttpClient;

private Configuration mConfiguration;
private ExecutorService mThreadPool;
private Headers.Builder mHeadersBuilder;

private AsyncOkHttp() {
    mHttpClient = new OkHttpClient();
    init(Configuration.createDefault());

    mHttpClient.setSslSocketFactory(null);
}

public static AsyncOkHttp getInstance() {
    if (instance == null) {
        synchronized (AsyncOkHttp.class) {
            if (null == instance) {
                instance = new AsyncOkHttp();
            }
        }
    }
    return instance;
}

public OkHttpClient getOkHttpClient() {
    return mHttpClient;
}

public void init(Configuration configuration) {
    if (configuration == null)
        throw new IllegalArgumentException("AsyncOkHttp can not be initialized with null");

    mConfiguration = configuration;

    mThreadPool = mConfiguration.getThreadPool();
    mHeadersBuilder = mConfiguration.getHeadersBuilder();
    mHttpClient.setConnectTimeout(mConfiguration.getConnectTimeout(), TimeUnit.SECONDS);
    mHttpClient.setWriteTimeout(mConfiguration.getWriteTimeout(), TimeUnit.SECONDS);
    mHttpClient.setReadTimeout(mConfiguration.getReadTimeout(), TimeUnit.SECONDS);
}

public Configuration getConfiguration() {
    return mConfiguration;
}

/**
 * /** Sets the socket factory used to secure HTTPS connections.
 * &lt;p/&gt;
 * &lt;p&gt;
 * If unset, a lazily created SSL socket factory will be used.
 */
public void setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
    mHttpClient.setSslSocketFactory(sslSocketFactory);
}

/**
 * Add a header for all requests.
 * 
 * @param name
 *        the name of header.
 * @param value
 *        the value of header.
 */
public void addHeader(String name, String value) {
    mHeadersBuilder.add(name, value);
}

/**
 * Remove a header for all requests.
 * 
 * @param name
 *        the name of header.
 */
public void removeHeader(String name) {
    mHeadersBuilder.removeAll(name);
}

// ************************************ HEAD ************************************

/**
 * Perform HTTP HEAD request with a RequestParams.
 * 
 * @param url
 * @param params
 * @param responseHandler
 */
public void head(String url, RequestParams params, BaseResponseHandler responseHandler) {
    head(params.toQueryString(url), responseHandler);
}

/**
 * Perform HTTP HEAD request.
 * 
 * @param url
 *        the URL of HTTP request.
 * @param responseHandler
 *        the callback of the response.
 */
public void head(String url, BaseResponseHandler responseHandler) {
    Request.Builder requestBuilder = createRequestBuilder(url).head();
    submitRequest(requestBuilder, responseHandler);
}

// ************************************ GET ************************************

/**
 * Perform HTTP GET request with a RequestParams.
 * 
 * @param url
 *        the URL of HTTP request.
 * @param params
 *        the parameter of Request Body.
 * @param responseHandler
 *        the callback of the response.
 */
public void get(String url, RequestParams params, BaseResponseHandler responseHandler) {
    get(params.toQueryString(url), responseHandler);
}

/**
 * Perform HTTP GET request.
 * 
 * @param url
 *        the URL of HTTP request.
 * @param responseHandler
 *        the callback of the response.
 */
public void get(String url, BaseResponseHandler responseHandler) {
    Request.Builder requestBuilder = createRequestBuilder(url).get();
    submitRequest(requestBuilder, responseHandler);
}

// ************************************ POST ************************************

/**
 * Perform HTTP POST request with a JSON string.
 * 
 * @param url
 *        the URL of HTTP request.
 * @param json
 *        the parameter of Request Body.
 * @param responseHandler
 *        the callback of the response.
 */
public void post(String url, String json, BaseResponseHandler responseHandler) {
    RequestBody requestBody = RequestBody.create(JSON, json);
    post(url, requestBody, responseHandler);
}

/**
 * Perform HTTP POST request with a RequestParams.
 * 
 * @param url
 *        the URL of HTTP request.
 * @param params
 *        the parameter of Request Body.
 * @param responseHandler
 *        the callback of the response.
 */
public void post(String url, RequestParams params, BaseResponseHandler responseHandler) {
    RequestBody requestBody = params.toRequestBody();
    post(url, requestBody, responseHandler);
}

/**
 * Perform HTTP POST request with a RequestBody.
 * 
 * @param url
 *        the URL of HTTP request.
 * @param requestBody
 *        the Request Body
 * @param responseHandler
 *        the callback of the response.
 */
public void post(String url, RequestBody requestBody, BaseResponseHandler responseHandler) {
    Request.Builder requestBuilder = createRequestBuilder(url).post(requestBody);
    submitRequest(requestBuilder, responseHandler);
}

/**
 * HTTP POST File.
 * @param url
 *        the URL of HTTP request.
 * @param file
 *        the file.
 * @param params
 *        the parameter of Request Body.
 * @param responseHandler
 *        the callback of the response.
 */
public void post(String url, File file, RequestParams params, BaseResponseHandler responseHandler) {
    RequestBody requestBody = params.toRequestBody();
    post(url, file, requestBody, responseHandler);
}

/**
 * HTTP POST File.
 * @param url
 *        the URL of HTTP request.
 * @param file
 *        the file.
 * @param requestBody
 *        the Request Body
 * @param responseHandler
 *        the callback of the response.
 */
public void post(String url, File file, RequestBody requestBody, BaseResponseHandler responseHandler) {
    Request.Builder requestBuilder = createRequestFileBuilder(url).post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file));
    submitRequest(requestBuilder, responseHandler);
}

/**
 * HTTP POST byte[].
 * @param url
 *        the URL of HTTP request.
 * @param content
 *        the byte[].
 * @param params
 *        the parameter of Request Body.
 * @param responseHandler
 *        the callback of the response.
 */
public void post(String url, byte[] content, RequestParams params, BaseResponseHandler responseHandler) {
    RequestBody requestBody = params.toRequestBody();
    post(url, content, requestBody, responseHandler);
}

/**
 * HTTP POST byte[].
 * @param url
 *        the URL of HTTP request.
 * @param content
 *        the byte[].
 * @param requestBody
 *        the Request Body
 * @param responseHandler
 *        the callback of the response.
 */
public void post(String url, byte[] content, RequestBody requestBody, BaseResponseHandler responseHandler) {
    Request.Builder requestBuilder = createRequestFileBuilder(url).post(RequestBody.create(MEDIA_TYPE_MARKDOWN, content));
    submitRequest(requestBuilder, responseHandler);
}

/**
 * HTTP POST ByteString(okio).
 * @param url
 *        the URL of HTTP request.
 * @param content
 *        the byte[].
 * @param params
 *        the parameter of Request Body.
 * @param responseHandler
 *        the callback of the response.
 */
public void post(String url, ByteString content, RequestParams params, BaseResponseHandler responseHandler) {
    RequestBody requestBody = params.toRequestBody();
    post(url, content, requestBody, responseHandler);
}

/**
 * HTTP POST ByteString(okio).
 * @param url
 *        the URL of HTTP request.
 * @param content
 *        the byte[].
 * @param requestBody
 *        the Request Body
 * @param responseHandler
 *        the callback of the response.
 */
public void post(String url, ByteString content, RequestBody requestBody, BaseResponseHandler responseHandler) {
    Request.Builder requestBuilder = createRequestFileBuilder(url).post(RequestBody.create(MEDIA_TYPE_MARKDOWN, content));
    submitRequest(requestBuilder, responseHandler);
}

// ************************************ PUT ************************************

/**
 * Perform HTTP PUT request with a JSON string.
 * 
 * @param url
 *        the URL of HTTP request.
 * @param json
 *        the parameter of Request Body.
 * @param responseHandler
 *        the callback of the response.
 */
public void put(String url, String json, BaseResponseHandler responseHandler) {
    RequestBody requestBody = RequestBody.create(JSON, json);
    put(url, requestBody, responseHandler);
}

/**
 * Perform HTTP PUT request with a RequestParams.
 * 
 * @param url
 *        the URL of HTTP request.
 * @param params
 *        the parameter of Request Body.
 * @param responseHandler
 *        the callback of the response.
 */
public void put(String url, RequestParams params, BaseResponseHandler responseHandler) {
    RequestBody requestBody = params.toRequestBody();
    put(url, requestBody, responseHandler);
}

/**
 * Perform HTTP PUT request with a RequestBody.
 * 
 * @param url
 *        the URL of HTTP request.
 * @param requestBody
 *        the Request Body
 * @param responseHandler
 *        the callback of the response.
 */
public void put(String url, RequestBody requestBody, BaseResponseHandler responseHandler) {
    Request.Builder requestBuilder = createRequestBuilder(url).put(requestBody);
    submitRequest(requestBuilder, responseHandler);
}

// ************************************ DELETE ************************************

/**
 * Perform HTTP DELETE request with a RequestParams.
 * 
 * @param url
 *        the URL of HTTP request.
 * @param params
 *        the parameter of Request Body.
 * @param responseHandler
 *        the callback of the response.
 */
public void delete(String url, RequestParams params, BaseResponseHandler responseHandler) {
    delete(params.toQueryString(url), responseHandler);
}

/**
 * Perform HTTP DELETE request.
 * 
 * @param url
 *        the URL of HTTP request.
 * @param responseHandler
 *        the callback of the response.
 */
public void delete(String url, BaseResponseHandler responseHandler) {
    Request.Builder request = createRequestBuilder(url).delete();
    submitRequest(request, responseHandler);
}

/**
 * Create a Request.Builder.
 * 
 * @param url
 *        the URL of HTTP request.
 * @return
 */
private Request.Builder createRequestBuilder(String url) {
    Request.Builder builder = new Request.Builder().url(url).tag(url).headers(mHeadersBuilder.build());
    return builder;
}

private Request.Builder createRequestFileBuilder(String url) {
    Request.Builder builder = new Request.Builder().url(url).tag(url).headers(mHeadersBuilder.build());
    return builder;
}

/**
 * Cancels all scheduled tasks tagged with tag. Requests that are already complete cannot be canceled.
 * 
 * @param url
 *        the URL of HTTP request.
 */
public void cancel(String url) {
    mHttpClient.cancel(url);
}

/**
 * Submit a Runnable task to thread pool.
 * 
 * @param builder
 * @param responseHandler
 *        the callback of the response.
 */
public void submitRequest(Request.Builder builder, BaseResponseHandler responseHandler) {
    submitRequest(builder.build(), responseHandler);
}

/**
 * Submit a Runnable task to thread pool.
 * 
 * @param request
 * @param responseHandler
 *        the callback of the response.
 */
public void submitRequest(Request request, BaseResponseHandler responseHandler) {
    RequestTask task = new RequestTask(mHttpClient, request, responseHandler);
    mThreadPool.submit(task);
}
</code></pre>

<h3>
<a id="高级" class="anchor" href="#%E9%AB%98%E7%BA%A7" aria-hidden="true"><span class="octicon octicon-link"></span></a>高级</h3>

<p>同步get
下载一个文件，打印他的响应头，以string形式打印响应体。
响应体的 string() 方法对于小文档来说十分方便、高效。但是如果响应体太大（超过1MB），应避免适应 string()方法 ，因为他会将把整个文档加载到内存中。
对于超过1MB的响应body，应使用流的方式来处理body。
private final OkHttpClient client = new OkHttpClient();
 
public void run() throws Exception {
    Request request = new Request.Builder()
        .url("<a href="http://publicobject.com/helloworld.txt">http://publicobject.com/helloworld.txt</a>")
        .build();
 
    Response response = client.newCall(request).execute();
    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
    Headers responseHeaders = response.headers();
    for (int i = 0; i &lt; responseHeaders.size(); i++) {
      System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
    }
 
    System.out.println(response.body().string());
}</p>

<p>取消一个Call
使用Call.cancel()可以立即停止掉一个正在执行的call。如果一个线程正在写请求或者读响应，将会引发IOException。当call没有必要的时候，使用这个api可以节约网络资源。例如当用户离开一个应用时。不管同步还是异步的call都可以取消。
你可以通过tags来同时取消多个请求。当你构建一请求时，使用RequestBuilder.tag(tag)来分配一个标签。之后你就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call。
private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
    private final OkHttpClient client = new OkHttpClient();</p>

<pre><code>public void run() throws Exception {
    Request request = new Request.Builder().url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
            .build();

    final long startNanos = System.nanoTime();
    final Call call = client.newCall(request);

    // Schedule a job to cancel the call in 1 second.
    executor.schedule(new Runnable() {
        @Override
        public void run() {
            Log.e("okhttp", "%.2f Canceling call.%n：                        " + (System.nanoTime() - startNanos) / 1e9f);
            System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
            call.cancel();
            Log.e("okhttp", "%.2f Canceled call.%n：                             " + (System.nanoTime() - startNanos) / 1e9f);
            System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
        }
    }, 1, TimeUnit.SECONDS);

    try {
        System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
        Response response = call.execute();
        System.out.printf("%.2f Call was expected to fail, but completed: %s%n", (System.nanoTime() - startNanos) / 1e9f, response);
    } catch (IOException e) {
        System.out.printf("%.2f Call failed as expected: %s%n", (System.nanoTime() - startNanos) / 1e9f, e);
    }
}

public static void main(String... args) throws Exception {
    new CancelCall().run();
}
</code></pre>

<p>响应缓存
为了缓存响应，你需要一个你可以读写的缓存目录，和缓存大小的限制。这个缓存目录应该是私有的，不信任的程序应不能读取缓存内容。
一个缓存目录同时拥有多个缓存访问是错误的。大多数程序只需要调用一次new OkHttp()，在第一次调用时配置好缓存，然后其他地方只需要调用这个实例就可以了。否则两个缓存示例互相干扰，破坏响应缓存，而且有可能会导致程序崩溃。
响应缓存使用HTTP头作为配置。你可以在请求头中添加Cache-Control: max-stale=3600 ,OkHttp缓存会支持。你的服务通过响应头确定响应缓存多长时间，例如使用Cache-Control: max-age=9600。
private final OkHttpClient client;</p>

<pre><code>public CacheResponse(File cacheDirectory) throws Exception {
    int cacheSize = 10 * 1024 * 1024; // 10 MiB
    Cache cache = new Cache(cacheDirectory, cacheSize);

    client = new OkHttpClient();
    client.setCache(cache);
}

public void run() throws Exception {
    Request request = new Request.Builder().url("http://publicobject.com/helloworld.txt").build();

    Response response1 = client.newCall(request).execute();
    if (!response1.isSuccessful())
        throw new IOException("Unexpected code " + response1);

    String response1Body = response1.body().string();
    Log.i("CacheResponse", "Response 1 response:          " + response1);
    Log.i("CacheResponse", "Response 1 cache response:    " + response1.cacheResponse());
    Log.i("CacheResponse", "Response 1 network response:  " + response1.networkResponse());
    System.out.println("Response 1 response:          " + response1);
    System.out.println("Response 1 cache response:    " + response1.cacheResponse());
    System.out.println("Response 1 network response:  " + response1.networkResponse());

    Response response2 = client.newCall(request).execute();
    if (!response2.isSuccessful())
        throw new IOException("Unexpected code " + response2);

    String response2Body = response2.body().string();
    Log.e("CacheResponse", "Response 2 response:          " + response2);
    Log.e("CacheResponse", "Response 2 cache response:    " + response2.cacheResponse());
    Log.e("CacheResponse", "Response 2 network response:  " + response2.networkResponse());

    Log.e("CacheResponse", "Response 2 equals Response 1? " + response1Body.equals(response2Body));

    System.out.println("Response 2 response:          " + response2);
    System.out.println("Response 2 cache response:    " + response2.cacheResponse());
    System.out.println("Response 2 network response:  " + response2.networkResponse());

    System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
}

public static void main(String... args) throws Exception {
    File file = new File(Environment.getExternalStorageDirectory(), "CacheResponse.tmp");
    new CacheResponse(file).run();
}
</code></pre>

<p>超时
没有响应时使用超时结束call。没有响应的原因可能是客户点链接问题、服务器可用性问题或者这之间的其他东西。OkHttp支持连接，读取和写入超时。</p>

<pre><code>private final OkHttpClient client;

public ConfigureTimeouts() throws Exception {
    client = new OkHttpClient();
    client.setConnectTimeout(10, TimeUnit.SECONDS);
    client.setWriteTimeout(10, TimeUnit.SECONDS);
    client.setReadTimeout(30, TimeUnit.SECONDS);
}

public void run() throws Exception {
    Request request = new Request.Builder().url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
            .build();

    Response response = client.newCall(request).execute();
    System.out.println("Response completed: " + response);
}

public static void main(String... args) throws Exception {
    new ConfigureTimeouts().run();
}
</code></pre>

<p>每个call的单独配置
使用OkHttpClient，所有的HTTP Client配置包括代理设置、超时设置、缓存设置。当你需要为单个call改变配置的时候，clone 一个 OkHttpClient。这个api将会返回一个浅拷贝（shallow copy），你可以用来单独自定义。下面的例子中，我们让一个请求是500ms的超时、另一个是3000ms的超时。
private final OkHttpClient client = new OkHttpClient();</p>

<p>public void run() throws Exception {
    Request request = new Request.Builder()
        .url("<a href="http://httpbin.org/delay/1">http://httpbin.org/delay/1</a>") // This URL is served with a 1 second delay.
        .build();</p>

<pre><code>try {
  Response response = client.clone() // Clone to make a customized OkHttp for this request.
      .setReadTimeout(500, TimeUnit.MILLISECONDS)
      .newCall(request)
      .execute();
  System.out.println("Response 1 succeeded: " + response);
} catch (IOException e) {
  System.out.println("Response 1 failed: " + e);
}

try {
  Response response = client.clone() // Clone to make a customized OkHttp for this request.
      .setReadTimeout(3000, TimeUnit.MILLISECONDS)
      .newCall(request)
      .execute();
  System.out.println("Response 2 succeeded: " + response);
} catch (IOException e) {
  System.out.println("Response 2 failed: " + e);
}
</code></pre>

<p>}
处理验证
OkHttp会自动重试未验证的请求。当响应是401 Not Authorized时，Authenticator会被要求提供证书。Authenticator的实现中需要建立一个新的包含证书的请求。如果没有证书可用，返回null来跳过尝试。
当需要实现一个Basic challenge， 使用Credentials.basic(username, password)来编码请求头。
private final OkHttpClient client = new OkHttpClient();</p>

<p>public void run() throws Exception {
    client.setAuthenticator(new Authenticator() {
      <a href="https://github.com/Override" class="user-mention">@Override</a> public Request authenticate(Proxy proxy, Response response) {
        System.out.println("Authenticating for response: " + response);
        System.out.println("Challenges: " + response.challenges());
        String credential = Credentials.basic("jesse", "password1");
        return response.request().newBuilder()
            .header("Authorization", credential)
            .build();
      }</p>

<pre><code>  @Override public Request authenticateProxy(Proxy proxy, Response response) {
    return null; // Null indicates no attempt to authenticate.
  }
});

Request request = new Request.Builder()
    .url("http://publicobject.com/secrets/hellosecret.txt")
    .build();

Response response = client.newCall(request).execute();
if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);

System.out.println(response.body().string());
</code></pre>

<p>}</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/hhxcode/hhx.github.io">hhx.github.io</a> is maintained by <a href="https://github.com/hhxcode">hhxcode</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
