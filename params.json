{"name":"hhx.github.io","tagline":"hhx Pages","body":"### OKHTTP\r\nAndroid系统提供了两种HTTP通信类，HttpURLConnection和HttpClient。\r\n尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。\r\nOkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。\r\n\r\nOkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。\r\n\r\n使用 OkHttp 无需重写您程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。\r\n\r\n### 基本使用\r\nHTTP GET\r\n\tOkHttpClient client = new OkHttpClient();\r\n\r\n\tString run(String url) throws IOException {\r\n\t\tRequest request = new Request.Builder().url(url).build();\r\n\r\n\t\tResponse response = client.newCall(request).execute();\r\n\t\treturn response.body().string();\r\n\t}\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tGetExample example = new GetExample();\r\n\t\tString response = example.run(\"https://raw.github.com/square/okhttp/master/README.md\");\r\n\t\tSystem.out.println(response);\r\n\t}\r\nRequest是OkHttp中访问的请求，Builder是辅助类。Response即OkHttp中的响应。\r\n\r\nResponse类：\r\n  /**\r\n   * Returns true if the code is in [200..300), which means the request was\r\n   * successfully received, understood, and accepted.\r\n   */\r\n  public boolean isSuccessful() {\r\n    return code >= 200 && code < 300;\r\n  }\r\nHTTP POST\r\nPOST提交String数据\r\npublic static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(\"text/x-markdown; charset=utf-8\");\r\n\r\n\tprivate final OkHttpClient client = new OkHttpClient();\r\n\r\n\tpublic void run() throws Exception {\r\n\t\tString postBody = \"\" + \"Releases\\n\" + \"--------\\n\" + \"\\n\" + \" * _1.0_ May 6, 2013\\n\" + \" * _1.1_ June 15, 2013\\n\"\r\n\t\t\t\t+ \" * _1.2_ August 11, 2013\\n\";\r\n\r\n\t\tRequest request = new Request.Builder().url(\"https://api.github.com/markdown/raw\")\r\n\t\t\t\t.post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)).build();\r\n\r\n\t\tResponse response = client.newCall(request).execute();\r\n\t\tif (!response.isSuccessful())\r\n\t\t\tthrow new IOException(\"Unexpected code \" + response);\r\n\r\n\t\tSystem.out.println(response.body().string());\r\n\t}\r\n\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tnew PostString().run();\r\n\t}\r\n使用Request的post方法来提交请求体RequestBody\r\n\r\nPOST提交键值对\r\nOkHttpClient client = new OkHttpClient();\r\nString post(String url, String json) throws IOException {\r\n \r\n     RequestBody formBody = new FormEncodingBuilder()\r\n    .add(\"platform\", \"android\")\r\n    .add(\"name\", \"bug\")\r\n    .add(\"subject\", \"XXXXXXXXXXXXXXX\")\r\n    .build();\r\n \r\n      Request request = new Request.Builder()\r\n      .url(url)\r\n      .post(body)\r\n      .build();\r\n \r\n      Response response = client.newCall(request).execute();\r\n    if (response.isSuccessful()) {\r\n        return response.body().string();\r\n    } else {\r\n        throw new IOException(\"Unexpected code \" + response);\r\n    }\r\n}\r\n\r\nPOST提交File\r\npublic static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(\"text/x-markdown; charset=utf-8\");\r\n\r\n\tprivate final OkHttpClient client = new OkHttpClient();\r\n\r\n\tpublic void run() throws Exception {\r\n\t\tFile file = new File(\"README.md\");\r\n\r\n\t\tRequest request = new Request.Builder().url(\"https://api.github.com/markdown/raw\")\r\n\t\t\t\t.post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file)).build();\r\n\r\n\t\tResponse response = client.newCall(request).execute();\r\n\t\tif (!response.isSuccessful())\r\n\t\t\tthrow new IOException(\"Unexpected code \" + response);\r\n\r\n\t\tSystem.out.println(response.body().string());\r\n\t}\r\n\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tnew PostFile().run();\r\n\t}\r\n\r\n### 总结\r\n通过上面的例子我们可以发现，OkHttp在很多时候使用都是很方便的，而且很多代码也有重复，因此特地整理了下面的工具类。\r\n注意：\r\n\r\nOkHttp官方文档并不建议我们创建多个OkHttpClient，因此全局使用一个。 如果有需要，可以使用clone方法，再进行自定义。这点在后面的高级教程里会提到。\r\n\r\nenqueue为OkHttp提供的异步方法，入门教程中并没有提到，后面的高级教程里会有解释。\r\nprivate static final MediaType JSON = MediaType.parse(\"application/json; charset=utf-8\");\r\n\tprivate static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(\"text/x-markdown; charset=utf-8\");\r\n\r\n\tprivate volatile static AsyncOkHttp instance;\r\n\r\n\tprivate final OkHttpClient mHttpClient;\r\n\r\n\tprivate Configuration mConfiguration;\r\n\tprivate ExecutorService mThreadPool;\r\n\tprivate Headers.Builder mHeadersBuilder;\r\n\r\n\tprivate AsyncOkHttp() {\r\n\t\tmHttpClient = new OkHttpClient();\r\n\t\tinit(Configuration.createDefault());\r\n\r\n\t\tmHttpClient.setSslSocketFactory(null);\r\n\t}\r\n\r\n\tpublic static AsyncOkHttp getInstance() {\r\n\t\tif (instance == null) {\r\n\t\t\tsynchronized (AsyncOkHttp.class) {\r\n\t\t\t\tif (null == instance) {\r\n\t\t\t\t\tinstance = new AsyncOkHttp();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn instance;\r\n\t}\r\n\r\n\tpublic OkHttpClient getOkHttpClient() {\r\n\t\treturn mHttpClient;\r\n\t}\r\n\r\n\tpublic void init(Configuration configuration) {\r\n\t\tif (configuration == null)\r\n\t\t\tthrow new IllegalArgumentException(\"AsyncOkHttp can not be initialized with null\");\r\n\r\n\t\tmConfiguration = configuration;\r\n\r\n\t\tmThreadPool = mConfiguration.getThreadPool();\r\n\t\tmHeadersBuilder = mConfiguration.getHeadersBuilder();\r\n\t\tmHttpClient.setConnectTimeout(mConfiguration.getConnectTimeout(), TimeUnit.SECONDS);\r\n\t\tmHttpClient.setWriteTimeout(mConfiguration.getWriteTimeout(), TimeUnit.SECONDS);\r\n\t\tmHttpClient.setReadTimeout(mConfiguration.getReadTimeout(), TimeUnit.SECONDS);\r\n\t}\r\n\r\n\tpublic Configuration getConfiguration() {\r\n\t\treturn mConfiguration;\r\n\t}\r\n\r\n\t/**\r\n\t * /** Sets the socket factory used to secure HTTPS connections.\r\n\t * <p/>\r\n\t * <p>\r\n\t * If unset, a lazily created SSL socket factory will be used.\r\n\t */\r\n\tpublic void setSslSocketFactory(SSLSocketFactory sslSocketFactory) {\r\n\t\tmHttpClient.setSslSocketFactory(sslSocketFactory);\r\n\t}\r\n\r\n\t/**\r\n\t * Add a header for all requests.\r\n\t * \r\n\t * @param name\r\n\t *        the name of header.\r\n\t * @param value\r\n\t *        the value of header.\r\n\t */\r\n\tpublic void addHeader(String name, String value) {\r\n\t\tmHeadersBuilder.add(name, value);\r\n\t}\r\n\r\n\t/**\r\n\t * Remove a header for all requests.\r\n\t * \r\n\t * @param name\r\n\t *        the name of header.\r\n\t */\r\n\tpublic void removeHeader(String name) {\r\n\t\tmHeadersBuilder.removeAll(name);\r\n\t}\r\n\r\n\t// ************************************ HEAD ************************************\r\n\r\n\t/**\r\n\t * Perform HTTP HEAD request with a RequestParams.\r\n\t * \r\n\t * @param url\r\n\t * @param params\r\n\t * @param responseHandler\r\n\t */\r\n\tpublic void head(String url, RequestParams params, BaseResponseHandler responseHandler) {\r\n\t\thead(params.toQueryString(url), responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * Perform HTTP HEAD request.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void head(String url, BaseResponseHandler responseHandler) {\r\n\t\tRequest.Builder requestBuilder = createRequestBuilder(url).head();\r\n\t\tsubmitRequest(requestBuilder, responseHandler);\r\n\t}\r\n\r\n\t// ************************************ GET ************************************\r\n\r\n\t/**\r\n\t * Perform HTTP GET request with a RequestParams.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param params\r\n\t *        the parameter of Request Body.\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void get(String url, RequestParams params, BaseResponseHandler responseHandler) {\r\n\t\tget(params.toQueryString(url), responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * Perform HTTP GET request.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void get(String url, BaseResponseHandler responseHandler) {\r\n\t\tRequest.Builder requestBuilder = createRequestBuilder(url).get();\r\n\t\tsubmitRequest(requestBuilder, responseHandler);\r\n\t}\r\n\r\n\t// ************************************ POST ************************************\r\n\r\n\t/**\r\n\t * Perform HTTP POST request with a JSON string.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param json\r\n\t *        the parameter of Request Body.\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void post(String url, String json, BaseResponseHandler responseHandler) {\r\n\t\tRequestBody requestBody = RequestBody.create(JSON, json);\r\n\t\tpost(url, requestBody, responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * Perform HTTP POST request with a RequestParams.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param params\r\n\t *        the parameter of Request Body.\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void post(String url, RequestParams params, BaseResponseHandler responseHandler) {\r\n\t\tRequestBody requestBody = params.toRequestBody();\r\n\t\tpost(url, requestBody, responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * Perform HTTP POST request with a RequestBody.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param requestBody\r\n\t *        the Request Body\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void post(String url, RequestBody requestBody, BaseResponseHandler responseHandler) {\r\n\t\tRequest.Builder requestBuilder = createRequestBuilder(url).post(requestBody);\r\n\t\tsubmitRequest(requestBuilder, responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * HTTP POST File.\r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param file\r\n\t *        the file.\r\n\t * @param params\r\n\t *        the parameter of Request Body.\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void post(String url, File file, RequestParams params, BaseResponseHandler responseHandler) {\r\n\t\tRequestBody requestBody = params.toRequestBody();\r\n\t\tpost(url, file, requestBody, responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * HTTP POST File.\r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param file\r\n\t *        the file.\r\n\t * @param requestBody\r\n\t *        the Request Body\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void post(String url, File file, RequestBody requestBody, BaseResponseHandler responseHandler) {\r\n\t\tRequest.Builder requestBuilder = createRequestFileBuilder(url).post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file));\r\n\t\tsubmitRequest(requestBuilder, responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * HTTP POST byte[].\r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param content\r\n\t *        the byte[].\r\n\t * @param params\r\n\t *        the parameter of Request Body.\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void post(String url, byte[] content, RequestParams params, BaseResponseHandler responseHandler) {\r\n\t\tRequestBody requestBody = params.toRequestBody();\r\n\t\tpost(url, content, requestBody, responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * HTTP POST byte[].\r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param content\r\n\t *        the byte[].\r\n\t * @param requestBody\r\n\t *        the Request Body\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void post(String url, byte[] content, RequestBody requestBody, BaseResponseHandler responseHandler) {\r\n\t\tRequest.Builder requestBuilder = createRequestFileBuilder(url).post(RequestBody.create(MEDIA_TYPE_MARKDOWN, content));\r\n\t\tsubmitRequest(requestBuilder, responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * HTTP POST ByteString(okio).\r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param content\r\n\t *        the byte[].\r\n\t * @param params\r\n\t *        the parameter of Request Body.\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void post(String url, ByteString content, RequestParams params, BaseResponseHandler responseHandler) {\r\n\t\tRequestBody requestBody = params.toRequestBody();\r\n\t\tpost(url, content, requestBody, responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * HTTP POST ByteString(okio).\r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param content\r\n\t *        the byte[].\r\n\t * @param requestBody\r\n\t *        the Request Body\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void post(String url, ByteString content, RequestBody requestBody, BaseResponseHandler responseHandler) {\r\n\t\tRequest.Builder requestBuilder = createRequestFileBuilder(url).post(RequestBody.create(MEDIA_TYPE_MARKDOWN, content));\r\n\t\tsubmitRequest(requestBuilder, responseHandler);\r\n\t}\r\n\r\n\t// ************************************ PUT ************************************\r\n\r\n\t/**\r\n\t * Perform HTTP PUT request with a JSON string.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param json\r\n\t *        the parameter of Request Body.\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void put(String url, String json, BaseResponseHandler responseHandler) {\r\n\t\tRequestBody requestBody = RequestBody.create(JSON, json);\r\n\t\tput(url, requestBody, responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * Perform HTTP PUT request with a RequestParams.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param params\r\n\t *        the parameter of Request Body.\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void put(String url, RequestParams params, BaseResponseHandler responseHandler) {\r\n\t\tRequestBody requestBody = params.toRequestBody();\r\n\t\tput(url, requestBody, responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * Perform HTTP PUT request with a RequestBody.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param requestBody\r\n\t *        the Request Body\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void put(String url, RequestBody requestBody, BaseResponseHandler responseHandler) {\r\n\t\tRequest.Builder requestBuilder = createRequestBuilder(url).put(requestBody);\r\n\t\tsubmitRequest(requestBuilder, responseHandler);\r\n\t}\r\n\r\n\t// ************************************ DELETE ************************************\r\n\r\n\t/**\r\n\t * Perform HTTP DELETE request with a RequestParams.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param params\r\n\t *        the parameter of Request Body.\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void delete(String url, RequestParams params, BaseResponseHandler responseHandler) {\r\n\t\tdelete(params.toQueryString(url), responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * Perform HTTP DELETE request.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void delete(String url, BaseResponseHandler responseHandler) {\r\n\t\tRequest.Builder request = createRequestBuilder(url).delete();\r\n\t\tsubmitRequest(request, responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * Create a Request.Builder.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t * @return\r\n\t */\r\n\tprivate Request.Builder createRequestBuilder(String url) {\r\n\t\tRequest.Builder builder = new Request.Builder().url(url).tag(url).headers(mHeadersBuilder.build());\r\n\t\treturn builder;\r\n\t}\r\n\r\n\tprivate Request.Builder createRequestFileBuilder(String url) {\r\n\t\tRequest.Builder builder = new Request.Builder().url(url).tag(url).headers(mHeadersBuilder.build());\r\n\t\treturn builder;\r\n\t}\r\n\r\n\t/**\r\n\t * Cancels all scheduled tasks tagged with tag. Requests that are already complete cannot be canceled.\r\n\t * \r\n\t * @param url\r\n\t *        the URL of HTTP request.\r\n\t */\r\n\tpublic void cancel(String url) {\r\n\t\tmHttpClient.cancel(url);\r\n\t}\r\n\r\n\t/**\r\n\t * Submit a Runnable task to thread pool.\r\n\t * \r\n\t * @param builder\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void submitRequest(Request.Builder builder, BaseResponseHandler responseHandler) {\r\n\t\tsubmitRequest(builder.build(), responseHandler);\r\n\t}\r\n\r\n\t/**\r\n\t * Submit a Runnable task to thread pool.\r\n\t * \r\n\t * @param request\r\n\t * @param responseHandler\r\n\t *        the callback of the response.\r\n\t */\r\n\tpublic void submitRequest(Request request, BaseResponseHandler responseHandler) {\r\n\t\tRequestTask task = new RequestTask(mHttpClient, request, responseHandler);\r\n\t\tmThreadPool.submit(task);\r\n\t}\r\n\r\n### 高级\r\n\r\n同步get\r\n下载一个文件，打印他的响应头，以string形式打印响应体。\r\n响应体的 string() 方法对于小文档来说十分方便、高效。但是如果响应体太大（超过1MB），应避免适应 string()方法 ，因为他会将把整个文档加载到内存中。\r\n对于超过1MB的响应body，应使用流的方式来处理body。\r\nprivate final OkHttpClient client = new OkHttpClient();\r\n \r\npublic void run() throws Exception {\r\n    Request request = new Request.Builder()\r\n        .url(\"http://publicobject.com/helloworld.txt\")\r\n        .build();\r\n \r\n    Response response = client.newCall(request).execute();\r\n    if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\r\n \r\n    Headers responseHeaders = response.headers();\r\n    for (int i = 0; i < responseHeaders.size(); i++) {\r\n      System.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i));\r\n    }\r\n \r\n    System.out.println(response.body().string());\r\n}\r\n\r\n取消一个Call\r\n使用Call.cancel()可以立即停止掉一个正在执行的call。如果一个线程正在写请求或者读响应，将会引发IOException。当call没有必要的时候，使用这个api可以节约网络资源。例如当用户离开一个应用时。不管同步还是异步的call都可以取消。\r\n你可以通过tags来同时取消多个请求。当你构建一请求时，使用RequestBuilder.tag(tag)来分配一个标签。之后你就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call。\r\nprivate final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\r\n\tprivate final OkHttpClient client = new OkHttpClient();\r\n\r\n\tpublic void run() throws Exception {\r\n\t\tRequest request = new Request.Builder().url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay.\r\n\t\t\t\t.build();\r\n\r\n\t\tfinal long startNanos = System.nanoTime();\r\n\t\tfinal Call call = client.newCall(request);\r\n\r\n\t\t// Schedule a job to cancel the call in 1 second.\r\n\t\texecutor.schedule(new Runnable() {\r\n\t\t\t@Override\r\n\t\t\tpublic void run() {\r\n\t\t\t\tLog.e(\"okhttp\", \"%.2f Canceling call.%n：                        \" + (System.nanoTime() - startNanos) / 1e9f);\r\n\t\t\t\tSystem.out.printf(\"%.2f Canceling call.%n\", (System.nanoTime() - startNanos) / 1e9f);\r\n\t\t\t\tcall.cancel();\r\n\t\t\t\tLog.e(\"okhttp\", \"%.2f Canceled call.%n：                             \" + (System.nanoTime() - startNanos) / 1e9f);\r\n\t\t\t\tSystem.out.printf(\"%.2f Canceled call.%n\", (System.nanoTime() - startNanos) / 1e9f);\r\n\t\t\t}\r\n\t\t}, 1, TimeUnit.SECONDS);\r\n\r\n\t\ttry {\r\n\t\t\tSystem.out.printf(\"%.2f Executing call.%n\", (System.nanoTime() - startNanos) / 1e9f);\r\n\t\t\tResponse response = call.execute();\r\n\t\t\tSystem.out.printf(\"%.2f Call was expected to fail, but completed: %s%n\", (System.nanoTime() - startNanos) / 1e9f, response);\r\n\t\t} catch (IOException e) {\r\n\t\t\tSystem.out.printf(\"%.2f Call failed as expected: %s%n\", (System.nanoTime() - startNanos) / 1e9f, e);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tnew CancelCall().run();\r\n\t}\r\n响应缓存\r\n为了缓存响应，你需要一个你可以读写的缓存目录，和缓存大小的限制。这个缓存目录应该是私有的，不信任的程序应不能读取缓存内容。\r\n一个缓存目录同时拥有多个缓存访问是错误的。大多数程序只需要调用一次new OkHttp()，在第一次调用时配置好缓存，然后其他地方只需要调用这个实例就可以了。否则两个缓存示例互相干扰，破坏响应缓存，而且有可能会导致程序崩溃。\r\n响应缓存使用HTTP头作为配置。你可以在请求头中添加Cache-Control: max-stale=3600 ,OkHttp缓存会支持。你的服务通过响应头确定响应缓存多长时间，例如使用Cache-Control: max-age=9600。\r\nprivate final OkHttpClient client;\r\n\r\n\tpublic CacheResponse(File cacheDirectory) throws Exception {\r\n\t\tint cacheSize = 10 * 1024 * 1024; // 10 MiB\r\n\t\tCache cache = new Cache(cacheDirectory, cacheSize);\r\n\r\n\t\tclient = new OkHttpClient();\r\n\t\tclient.setCache(cache);\r\n\t}\r\n\r\n\tpublic void run() throws Exception {\r\n\t\tRequest request = new Request.Builder().url(\"http://publicobject.com/helloworld.txt\").build();\r\n\r\n\t\tResponse response1 = client.newCall(request).execute();\r\n\t\tif (!response1.isSuccessful())\r\n\t\t\tthrow new IOException(\"Unexpected code \" + response1);\r\n\r\n\t\tString response1Body = response1.body().string();\r\n\t\tLog.i(\"CacheResponse\", \"Response 1 response:          \" + response1);\r\n\t\tLog.i(\"CacheResponse\", \"Response 1 cache response:    \" + response1.cacheResponse());\r\n\t\tLog.i(\"CacheResponse\", \"Response 1 network response:  \" + response1.networkResponse());\r\n\t\tSystem.out.println(\"Response 1 response:          \" + response1);\r\n\t\tSystem.out.println(\"Response 1 cache response:    \" + response1.cacheResponse());\r\n\t\tSystem.out.println(\"Response 1 network response:  \" + response1.networkResponse());\r\n\r\n\t\tResponse response2 = client.newCall(request).execute();\r\n\t\tif (!response2.isSuccessful())\r\n\t\t\tthrow new IOException(\"Unexpected code \" + response2);\r\n\r\n\t\tString response2Body = response2.body().string();\r\n\t\tLog.e(\"CacheResponse\", \"Response 2 response:          \" + response2);\r\n\t\tLog.e(\"CacheResponse\", \"Response 2 cache response:    \" + response2.cacheResponse());\r\n\t\tLog.e(\"CacheResponse\", \"Response 2 network response:  \" + response2.networkResponse());\r\n\r\n\t\tLog.e(\"CacheResponse\", \"Response 2 equals Response 1? \" + response1Body.equals(response2Body));\r\n\r\n\t\tSystem.out.println(\"Response 2 response:          \" + response2);\r\n\t\tSystem.out.println(\"Response 2 cache response:    \" + response2.cacheResponse());\r\n\t\tSystem.out.println(\"Response 2 network response:  \" + response2.networkResponse());\r\n\r\n\t\tSystem.out.println(\"Response 2 equals Response 1? \" + response1Body.equals(response2Body));\r\n\t}\r\n\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tFile file = new File(Environment.getExternalStorageDirectory(), \"CacheResponse.tmp\");\r\n\t\tnew CacheResponse(file).run();\r\n\t}\r\n\r\n超时\r\n没有响应时使用超时结束call。没有响应的原因可能是客户点链接问题、服务器可用性问题或者这之间的其他东西。OkHttp支持连接，读取和写入超时。\r\n\r\n\tprivate final OkHttpClient client;\r\n\r\n\tpublic ConfigureTimeouts() throws Exception {\r\n\t\tclient = new OkHttpClient();\r\n\t\tclient.setConnectTimeout(10, TimeUnit.SECONDS);\r\n\t\tclient.setWriteTimeout(10, TimeUnit.SECONDS);\r\n\t\tclient.setReadTimeout(30, TimeUnit.SECONDS);\r\n\t}\r\n\r\n\tpublic void run() throws Exception {\r\n\t\tRequest request = new Request.Builder().url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay.\r\n\t\t\t\t.build();\r\n\r\n\t\tResponse response = client.newCall(request).execute();\r\n\t\tSystem.out.println(\"Response completed: \" + response);\r\n\t}\r\n\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tnew ConfigureTimeouts().run();\r\n\t}\r\n\r\n每个call的单独配置\r\n使用OkHttpClient，所有的HTTP Client配置包括代理设置、超时设置、缓存设置。当你需要为单个call改变配置的时候，clone 一个 OkHttpClient。这个api将会返回一个浅拷贝（shallow copy），你可以用来单独自定义。下面的例子中，我们让一个请求是500ms的超时、另一个是3000ms的超时。\r\nprivate final OkHttpClient client = new OkHttpClient();\r\n \r\npublic void run() throws Exception {\r\n    Request request = new Request.Builder()\r\n        .url(\"http://httpbin.org/delay/1\") // This URL is served with a 1 second delay.\r\n        .build();\r\n \r\n    try {\r\n      Response response = client.clone() // Clone to make a customized OkHttp for this request.\r\n          .setReadTimeout(500, TimeUnit.MILLISECONDS)\r\n          .newCall(request)\r\n          .execute();\r\n      System.out.println(\"Response 1 succeeded: \" + response);\r\n    } catch (IOException e) {\r\n      System.out.println(\"Response 1 failed: \" + e);\r\n    }\r\n \r\n    try {\r\n      Response response = client.clone() // Clone to make a customized OkHttp for this request.\r\n          .setReadTimeout(3000, TimeUnit.MILLISECONDS)\r\n          .newCall(request)\r\n          .execute();\r\n      System.out.println(\"Response 2 succeeded: \" + response);\r\n    } catch (IOException e) {\r\n      System.out.println(\"Response 2 failed: \" + e);\r\n    }\r\n}\r\n处理验证\r\nOkHttp会自动重试未验证的请求。当响应是401 Not Authorized时，Authenticator会被要求提供证书。Authenticator的实现中需要建立一个新的包含证书的请求。如果没有证书可用，返回null来跳过尝试。\r\n当需要实现一个Basic challenge， 使用Credentials.basic(username, password)来编码请求头。\r\nprivate final OkHttpClient client = new OkHttpClient();\r\n \r\npublic void run() throws Exception {\r\n    client.setAuthenticator(new Authenticator() {\r\n      @Override public Request authenticate(Proxy proxy, Response response) {\r\n        System.out.println(\"Authenticating for response: \" + response);\r\n        System.out.println(\"Challenges: \" + response.challenges());\r\n        String credential = Credentials.basic(\"jesse\", \"password1\");\r\n        return response.request().newBuilder()\r\n            .header(\"Authorization\", credential)\r\n            .build();\r\n      }\r\n \r\n      @Override public Request authenticateProxy(Proxy proxy, Response response) {\r\n        return null; // Null indicates no attempt to authenticate.\r\n      }\r\n    });\r\n \r\n    Request request = new Request.Builder()\r\n        .url(\"http://publicobject.com/secrets/hellosecret.txt\")\r\n        .build();\r\n \r\n    Response response = client.newCall(request).execute();\r\n    if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\r\n \r\n    System.out.println(response.body().string());\r\n}\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}